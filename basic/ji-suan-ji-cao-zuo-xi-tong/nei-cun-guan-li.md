# 内存管理

## 虚拟内存 <a id="%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"></a>

虚拟内存是为了让物理内存扩充成更大的逻辑内存，从而让程序获得等多的可用内存。

为了更好地管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己地地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续地物理内存，也不需要所有页都必须在物理内存中。当程序引用到物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调用全部内存就可以运行，这使得有限的内存运行大程序成为可能。例如一台计算机可以产生16地址，那么一个程序的地址空间范围时0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。

![](../../.gitbook/assets/image%20%2871%29.png)

## 分页系统地址映射 <a id="%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"></a>

内存管理单元（MMU）管理者地址空间和物理内存的转换，其中的页表（Page Table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着16个页，这16个页需要用4个比特来进行索引定位。例如对于虚拟地址（0010 000000000100），前4位是存储页面号2，读取表项内容为1101，页表项最后一个表示是否存于内存中，1表示存在。后12为存储偏移量。这个页对应的页框地址为110 00000000010.

## 页面置换算法 <a id="%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"></a>

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中，此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成是磁盘的缓存。在缓存系统中，缓存的大小有效，当有心的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 1.最佳 Optital replacement algorithm, OPT <a id="1.%E6%9C%80%E4%BD%B3"></a>

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法指导一个页面多长时间不再被访问。

### 2.最近最久未使用 Least Recently Used, LRU <a id="2.%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8"></a>

虽然无法指导将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU将最近最久未使用的页面换出。

为了实现LRU，需要在内存中维护一个所有页面的链表，当一个页面被访问时，将这个页面移动到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种LRU方式的代价很高。

### 3.最近未使用 Not Recently Used <a id="3.%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8"></a>

每个页面都有两个状态位：R和M，当页面被访问时设置页面的R=1，当页面被修改时设置M=1。其中R位会定时被清零。可以将页面分为以下四类：

* R=0, M=0
* R=0, M=1
* R=1, M=0
* R=1, M=1

当发生缺页中断时，NRU算法随机地从类编号最小地非空类中挑选一个页面将它换出。NRU优先换出已经被修改的脏页面（R=0, M=1），而不是被频繁使用的干净页面（R=1, M=0）。

### 4.先进先出 First In First Out, FIFO <a id="4.%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"></a>

选择换出的页面是最先进入的页面。

该算法会将那么经常被访问的页面也被换出，从而使缺页率升高。

### 5.第二次机会算法 <a id="5.%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"></a>

FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问（读或写）时设置该页面的R位为1。需要替换的时候，检查最老页面的R位，如果R位是0，那么这个页面既老又没有被使用，可以立即置换掉；如果是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

![](../../.gitbook/assets/image%20%28101%29.png)

### 6.时钟 Clock <a id="6.%E6%97%B6%E9%92%9F"></a>

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用唤醒链表将页面连接起来，再使用一个指针指向最老的页面。

![](../../.gitbook/assets/image%20%2841%29.png)

## 分段 <a id="%E5%88%86%E6%AE%B5"></a>

虚拟内存使用的是分页技术，也就是将地址空间划分为固定大小的页，每一页再与内存进行映射。

下图为一个编译器在编译过程中建立的多个表，有4个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

![](../../.gitbook/assets/image%20%2866%29.png)

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

![](../../.gitbook/assets/image%20%28107%29.png)

## 段页式 <a id="%E6%AE%B5%E9%A1%B5%E5%BC%8F"></a>

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9jMzM2ZDY1MTEwNTI0YWUyODk0NzdkYzJhMDYzNmVkZjZhZWY5YTNjLzY4NzQ3NDcwNzMzYTJmMmY2MzczMmQ2ZTZmNzQ2NTczMmQzMTMyMzUzNjMxMzAzOTM3MzkzNjJlNjM2ZjczMmU2MTcwMmQ2Nzc1NjE2ZTY3N2E2ODZmNzUyZTZkNzk3MTYzNmM2Zjc1NjQyZTYzNmY2ZDJmNjUzMDM5MzAzMDYyNjIzMjJkMzIzMjMwNjEyZDM0MzM2MjM3MmQzOTYxNjEzOTJkMzE2NDM1NjM2NDM1MzU2NjY2MzUzNjY1MmU3MDZlNjc?x-oss-process=image/format,png)![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)​

## 分页和分段的比较 <a id="%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"></a>

* 对程序员的透明性：分页透明，但是分段需要程序员显式地划分每个段。
* 地址空间的维度：分页是一维地址空间，分段是二维的。
* 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

